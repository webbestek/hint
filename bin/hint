#!/usr/bin/env bash
# hint ‚Äî Starship-ready command palette (dynamic-path runtime)
# v1.0.0 ‚Äî Clean, fast, and safe by default.

set -euo pipefail

fail() { printf "hint: %s\n" "$*" >&2; exit 1; }
on_err() { rc=$?; printf "hint: something went wrong (exit %s). Try: hint --doctor\n" "$rc" >&2; exit "$rc"; }
trap on_err ERR

# Resolve runtime root based on this script's path (works via symlink)
resolve_root() {
  local src="${BASH_SOURCE[0]}"
  while [ -L "$src" ]; do
    local dir; dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  local dir; dir="$(cd -P "$(dirname "$src")/.." && pwd)"
  printf "%s\n" "$dir"
}
HINT_ROOT_DEFAULT="$(resolve_root)"
HINT_ROOT="${HINT_ROOT:-$HINT_ROOT_DEFAULT}"
HINT_HINTDIR="${HINT_HINTDIR:-$HINT_ROOT/hint}"
HINT_CUSTOM_FILE="${HINT_CUSTOM_FILE:-$HOME/.config/hint/custom.sh}"
HINT_PLUGIN_DIRS="${HINT_PLUGIN_DIRS:-}"

has(){ command -v "$1" >/dev/null 2>&1; }
is_tty(){ [[ -t 1 ]]; }
bold(){ is_tty && tput bold || true; }
dim(){ is_tty && tput dim || true; }
sg(){ is_tty && tput sgr0 || true; }
grey(){ is_tty && tput setaf 8 || true; }
# color palette (fallback to no color if not a TTY)
c_red(){ is_tty && tput setaf 1 || true; }
c_green(){ is_tty && tput setaf 2 || true; }
c_yellow(){ is_tty && tput setaf 3 || true; }
c_blue(){ is_tty && tput setaf 4 || true; }
c_magenta(){ is_tty && tput setaf 5 || true; }
c_cyan(){ is_tty && tput setaf 6 || true; }
hr(){ printf "%s" "$(grey)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ$(sg)"; }

teach_tip(){
  local tips=(
    'Ctrl-R searches history; Arrow keys to select, Enter to run.'
    'Use `tldr <cmd>` for short, example-driven manuals.'
    'Use `journalctl -p 3 -xb` to see errors from this boot.'
    'Use `ss -tulpn` to list listening ports.'
    'Use `dig +trace example.com` to debug DNS.'
    'Use `sudo lsof +L1` to find deleted-but-open files eating disk.'
  )
  if has shuf; then shuf -e "${tips[@]}" -n 1; else printf "%s\n" "${tips[0]}"; fi
}


context_hints(){
  local cwd="$PWD"
  # Git repo
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf "GIT\tCurrent branch\tgit rev-parse --abbrev-ref HEAD\tShow current branch\n"
    printf "GIT\tChanged files\tgit status -s\tShort status\n"
    printf "GIT\tStash & pull\tgit stash && git pull --rebase\tUpdate safely\n"
    printf "GIT\tFix last commit\tgit commit --amend --no-edit\tAmend without changing message\n"
  fi
  # Node / npm
  if [[ -f "$cwd/package.json" ]]; then
    printf "NODE\tInstall\tnpm ci\tClean install from lockfile\n"
    printf "NODE\tAudit\tnpm audit\tVulnerability scan\n"
    if command -v jq >/dev/null 2>&1; then
      while IFS= read -r s; do
        printf "NODE\tRun: %s\tnpm run %s\tFrom package.json scripts\n" "$s" "$s"
      done < <(jq -r '.scripts | keys[]?' "$cwd/package.json" 2>/dev/null || true)
    fi
  fi
  # PHP / Composer
  if [[ -f "$cwd/composer.json" ]]; then
    printf "PHP\tComposer install\tcomposer install\tInstall dependencies\n"
    if command -v jq >/dev/null 2>&1; then
      while IFS= read -r s; do
        printf "PHP\tComposer script: %s\tcomposer run %s\tFrom composer.json scripts\n" "$s" "$s"
      done < <(jq -r '.scripts | keys[]?' "$cwd/composer.json" 2>/dev/null || true)
    fi
  fi
  # Docker Compose
  if [[ -f "$cwd/docker-compose.yml" || -f "$cwd/compose.yml" ]]; then
    printf "DOCKER\tCompose up\tdocker compose up -d\tStart services\n"
    printf "DOCKER\tCompose logs\tdocker compose logs -f\tFollow logs\n"
    printf "DOCKER\tCompose down\tdocker compose down\tStop services\n"
  fi
  # Makefile
  if [[ -f "$cwd/Makefile" ]]; then
    printf "OPS\tMake help\tmake help\tList tasks (if provided)\n"
    printf "OPS\tMake build\tmake build\tBuild project\n"
  fi
  # .env present
  if [[ -f "$cwd/.env" ]]; then
    printf "OPS\tShow .env keys\tawk -F= '/^[A-Za-z_][A-Za-z0-9_]*=/{print $1}' .env\tList var names from .env\n"
  fi
}

collect_from_dir(){
  local dir="$1"; [[ -d "$dir" ]] || return 0
  while IFS= read -r -d '' f; do bash "$f" || true; done < <(find "$dir" -type f -name '*.sh' -print0 | sort -z)
}

collect_hints(){
  context_hints || true

  # All subdirs of HINT_HINTDIR (category-agnostic), plus custom and plugins
  [[ -d "$HINT_HINTDIR" ]] && while IFS= read -r -d '' sub; do collect_from_dir "$sub"; done < <(find "$HINT_HINTDIR" -maxdepth 1 -mindepth 1 -type d -print0 | sort -z)
  # Plugins
  if [[ -n "$HINT_PLUGIN_DIRS" ]]; then
    IFS=':' read -r -a plugs <<< "$HINT_PLUGIN_DIRS"
    for p in "${plugs[@]}"; do [[ -d "$p/hint" ]] && while IFS= read -r -d '' sub; do collect_from_dir "$sub"; done < <(find "$p/hint" -maxdepth 1 -mindepth 1 -type d -print0 | sort -z); done
  fi
  # Custom
  [[ -f "$HINT_CUSTOM_FILE" ]] && bash "$HINT_CUSTOM_FILE" || true
}

print_compact(){
  local all="$1"
  echo; printf "%sHINTS%s  %s(type 'hint i' for interactive)%s\n" "$(bold)" "$(sg)" "$(dim)" "$(sg)"
  hr; echo
  echo "$all" | awk -F'\t' '{
    cat=$1; label=$2; cmd=$3; why=$4;
    gsub(/\r/,"",cat); gsub(/\r/,"",label); gsub(/\r/,"",cmd); gsub(/\r/,"",why);
    if (!seen[cat]++) { order[++n]=cat }
    lines[cat]=lines[cat] sprintf("  ‚Ä¢ %-30s %s\n", label, cmd)
  } END { for (i=1;i<=n;i++){ c=order[i]; printf("\n[%s]\n%s", c, lines[c]) } }'
  echo; printf "%sTeach:%s %s\n" "$(bold)" "$(sg)" "$(teach_tip)"; echo
}

fzf_menu(){
  local all="$1"; local menu
  menu="$(echo "$all" | awk -F'\t' '{printf("[%s] %s\t%s\t‚Äî %s\n",$1,$2,$3,($4==""?"":$4))}')"
  if has fzf; then
    echo "$menu" | FZF_DEFAULT_OPTS="--ansi --no-sort --height 90% --border --layout=reverse --with-nth=1,2 --delimiter='\t' --prompt='hint > '" \
      fzf --header "Teach: $(teach_tip)" --preview "awk -F'\t' '{print \$0}' <<< {}" | awk -F'\t' '{print $2}'
  else
    print_compact "$all"
  fi
}


print_compact(){
  local all="$1"
  echo
  printf "%s%sHINTS%s  %s(type 'hint i' for interactive)%s
" "$(c_cyan)" "$(bold)" "$(sg)" "$(dim)" "$(sg)"
  hr; echo
  echo "$all" | awk -F'	' '{
    cat=$1; label=$2; cmd=$3; why=$4;
    gsub(/
/,"",cat); gsub(/
/,"",label); gsub(/
/,"",cmd); gsub(/
/,"",why);
    if (!seen[cat]++) { order[++n]=cat }
    lines[cat]=lines[cat] sprintf("%s  ‚Ä¢ %-28s%s  %s%s%s
", "", label, "", cmd, (why? "  ‚Äî ":""), why)
  } END {
    for (i=1;i<=n;i++) {
      c=order[i];
      printf("
%s[%s]%s
", "[36m[1m", c, "[0m"); # cyan bold
      printf("%s", lines[c]);
    }
  }'
  echo
  printf "%sTip:%s %sRun the command as shown. Edit anything in <angle brackets> first.%s
" "$(c_yellow)" "$(sg)" "$(dim)" "$(sg)"
  echo
}

print_beginner(){
  local all="$1"
  echo
  printf "%s%sHINTS (Beginner Mode)%s  %s(type 'hint i' for interactive)%s
" "$(c_green)" "$(bold)" "$(sg)" "$(dim)" "$(sg)"
  hr; echo
  echo "$all" | awk -F'	' '{
    cat=$1; label=$2; cmd=$3; why=$4;
    gsub(/
/,"",cat); gsub(/
/,"",label); gsub(/
/,"",cmd); gsub(/
/,"",why);
    if (!seen[cat]++) { order[++n]=cat }
    block[cat]=block[cat] \
      sprintf("
  ‚Ä¢ %s
    %sWhat it does:%s %s
    %sHow to use:%s  Copy and paste this command, then press Enter.
    %sCommand:%s   %s
", \
              label, "[1m", "[0m", (why?why:"No description yet"), "[1m", "[0m", "[1m", "[0m", cmd);
  } END {
    for (i=1;i<=n;i++) {
      c=order[i];
      printf("
%s[%s]%s
", "[34m[1m", c, "[0m"); # blue bold
      printf("%s
", block[c]);
    }
  }'
  echo
  printf "%sReminder:%s If you see <like-this>, replace it with your value before running.
" "$(c_yellow)" "$(sg)"
  echo
}
doctor(){
  printf "hint doctor ‚Äî inspecting environment\n"
  case ":$PATH:" in *":$HOME/.local/bin:"*) echo "‚úÖ PATH has ~/.local/bin" ;; *)
    echo "‚ö†Ô∏è  PATH missing ~/.local/bin ‚Äî add: export PATH=\"\$HOME/.local/bin:\$PATH\" to ~/.bashrc" ;; esac
  if has starship; then echo "‚úÖ starship present"; else echo "‚ö†Ô∏è  starship not found (optional for sysline)"; fi
  if command -v hint >/dev/null 2>&1; then echo "‚úÖ hint in PATH: $(command -v hint)"; else echo "‚ùå hint not on PATH"; fi
  echo "HINT_ROOT: $HINT_ROOT"
  echo "HINT_HINTDIR: $HINT_HINTDIR"
  echo "HINT_CUSTOM_FILE: $HINT_CUSTOM_FILE (exists: $( [[ -f "$HINT_CUSTOM_FILE" ]] && echo yes || echo no ))"
  local cnt=0; while IFS= read -r -d '' f; do cnt=$((cnt+1)); done < <(find "$HINT_HINTDIR" -type f -name '*.sh' -print0 2>/dev/null || true)
  echo "Found $cnt hint scripts under $HINT_HINTDIR"
}

debug_dump(){
  echo "DEBUG:"
  echo "  SHELL     = ${SHELL:-}"
  echo "  HINT_ROOT = ${HINT_ROOT}"
  echo "  HINT_HINTDIR = ${HINT_HINTDIR}"
  echo "  CUSTOM    = ${HINT_CUSTOM_FILE} (exists: $( [[ -f "$HINT_CUSTOM_FILE" ]] && echo yes || echo no ))"
}

case "${1:-}" in
  --beginner) ALL="$(collect_hints)"; print_beginner "$ALL" ;;

  --doctor) doctor ;;
  --debug) debug_dump ;;
  i|interactive) ALL="$(collect_hints)"; fzf_menu "$ALL" ;;
  --all|"") ALL="$(collect_hints)"; print_compact "$ALL" ;;
  *) echo "hint: unknown option '$1'"; echo "usage: hint [i|--all|--doctor|--debug]"; exit 2 ;;
esac
